## API Report File for "@dassie/lib-oer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ConditionalExcept } from 'type-fest';
import type { ConditionalPick } from 'type-fest';
import type { Opaque } from 'type-fest';
import type { ReadonlyTuple } from 'type-fest';
import type { Simplify } from 'type-fest';

// @public (undocumented)
export type AnyOerType = OerType<unknown>;

// @public (undocumented)
export const bitstring: <TBitDefinition extends number>(bits: TBitDefinition, { variableLength }?: BitstringOptions) => OerVariableBitstring<TBitDefinition> | OerFixedBitstring<TBitDefinition>;

// @public (undocumented)
export const boolean: () => OerBoolean;

// @public (undocumented)
export const choice: <TOptions extends ObjectShape>(options: TOptions) => OerChoice<TOptions>;

// @public (undocumented)
export type EncodingType = "utf8" | "ascii";

// @public (undocumented)
export const enumerated: <TEnumeration extends Record<string, number>>(enumeration: TEnumeration) => OerEnumerated<TEnumeration>;

// @public (undocumented)
export interface FixedIntegerOptions extends IntegerOptions {
    // (undocumented)
    maximumValue: bigint;
    // (undocumented)
    minimumValue: bigint;
}

// @public (undocumented)
export const hexToUint8Array: (hexString: string) => Uint8Array;

// @public (undocumented)
export const ia5String: (length?: Range_2<number>) => OerString;

// @public (undocumented)
export type Infer<TOerType extends AnyOerType> = TOerType extends OerType<infer T, never> ? T : never;

// @public (undocumented)
export type InferObjectParseShape<TShape extends ObjectShape> = {
    [key in keyof TShape]: Infer<TShape[key]>;
};

// @public (undocumented)
export type InferObjectSerializeShape<TShape extends ObjectShape> = {
    [key in keyof ConditionalExcept<TShape, OerConstant<unknown, unknown> | OerOptional<unknown, unknown>>]: InferSerialize<TShape[key]>;
} & {
    [key in keyof ConditionalPick<TShape, OerOptional<unknown, unknown>>]?: InferSerialize<TShape[key]>;
};

// @public (undocumented)
export const int16Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const int16Number: () => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export const int32Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const int32Number: () => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export const int64Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const int8Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const int8Number: () => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export const integerAsBigint: (range?: Range_2<bigint>) => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const integerAsNumber: (range: Range_2<number>) => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export interface IntegerAsNumberOptions {
    // (undocumented)
    range: FixedRange<number>;
}

// @public (undocumented)
export const numericString: (length?: Range_2<number>) => OerString;

// @public (undocumented)
export const objectIdentifier: () => OerObjectIdentifier;

// @public (undocumented)
export type ObjectShape = Record<string, AnyOerType>;

// @public (undocumented)
export const octetString: (length?: Range_2<number>) => OerFixedOctetString | OerVariableOctetString;

// @public (undocumented)
export class OerBoolean extends OerType<boolean> {
    // (undocumented)
    parseWithContext({ uint8Array, allowNoncanonical }: ParseContext, offset: number): ParseError | readonly [boolean, 1];
    // (undocumented)
    serializeWithContext(input: boolean): {
        ({ uint8Array }: SerializeContext, offset: number): void;
        size: number;
    };
}

// @public (undocumented)
export class OerChoice<TOptions extends ObjectShape> extends OerType<Simplify<InferOptionValues<TOptions>>, Simplify<InferOptionSerializeValues<TOptions>>> {
    constructor(options: TOptions);
    // (undocumented)
    readonly options: TOptions;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [Simplify<InferOptionValues<TOptions>, {}>, number];
    // (undocumented)
    serializeWithContext(input: Simplify<InferOptionSerializeValues<TOptions>>): SerializeError | {
        (context: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
}

// @public (undocumented)
export class OerEnumerated<TEnumeration extends Record<string, number>> extends OerType<keyof TEnumeration> {
    constructor(enumeration: TEnumeration);
    // (undocumented)
    readonly enumeration: TEnumeration;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [keyof TEnumeration, number];
    // (undocumented)
    serializeWithContext(input: string): SerializeError | {
        ({ uint8Array }: SerializeContext, offset: number): void;
        size: number;
    };
}

// @public (undocumented)
export class OerFixedBitstring<TBitDefinition extends number> extends OerType<InferBitstringValue<TBitDefinition>> {
    constructor(bits: TBitDefinition);
    // (undocumented)
    readonly bits: TBitDefinition;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [ReadonlyTuple<boolean, TBitDefinition>, number];
    // (undocumented)
    serializeWithContext(input: InferBitstringValue<TBitDefinition>): SerializeError | {
        (context: SerializeContext, offset: number): void;
        size: number;
    };
}

// @public (undocumented)
export abstract class OerFixedIntegerBigint extends OerIntegerBigint {
    constructor(options: FixedIntegerOptions);
    // (undocumented)
    readonly options: FixedIntegerOptions;
    // (undocumented)
    parseWithContext({ uint8Array, dataView }: ParseContext, offset: number): ParseError | readonly [bigint, number];
    // (undocumented)
    serializeWithContext(value: bigint): {
        (context: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
    // (undocumented)
    abstract readonly size: 8 | 16 | 32 | 64;
    // (undocumented)
    abstract readonly type: "Uint" | "Int";
}

// @public (undocumented)
export abstract class OerFixedIntegerNumber extends OerIntegerNumber {
    constructor(options: IntegerAsNumberOptions);
    // (undocumented)
    readonly options: IntegerAsNumberOptions;
    // (undocumented)
    parseWithContext({ uint8Array, dataView }: ParseContext, offset: number): ParseError | readonly [number, number];
    // (undocumented)
    serializeWithContext(value: number): {
        (context: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
    // (undocumented)
    abstract readonly size: 8 | 16 | 32;
    // (undocumented)
    abstract readonly type: "Uint" | "Int";
}

// @public (undocumented)
export class OerFixedOctetString extends OerType<Uint8Array, Uint8Array | Serializer> {
    constructor(length: SafeUnsignedInteger);
    // (undocumented)
    containing<T>(subType: OerType<T>): {
        readonly octetStringType: OerFixedOctetString | OerVariableOctetString;
        readonly subType: OerType<T, T>;
        parseWithContext(context: ParseContext, offset: number): ParseError | readonly [T, number];
        serializeWithContext(value: Uint8Array | T): SerializeError | {
            (context: BaseContext, offset: number): void;
            size: SafeUnsignedInteger;
        } | {
            (context: BaseContext, offset: number): SerializeError | undefined;
            size: number;
        };
        _tag: readonly [tagValue: number, tagClass: TagMarker] | undefined;
        parse(input: Uint8Array, offset?: number, options?: ParseOptions): {
            success: false;
            failure: ParseError;
        } | {
            success: true;
            value: T;
            length: number;
        };
        serialize(value: Uint8Array | T): {
            success: true;
            value: Uint8Array;
        } | {
            success: false;
            failure: SerializeError;
        };
        tag(tagValue: number, tagClass?: "application" | "context" | "private"): any;
        optional(): OerOptional<T, Uint8Array | T>;
        default(value: T): OerOptional<T, Uint8Array | T>;
        constant<TParseValue, TSerializeValue>(this: OerType<TParseValue, TSerializeValue>, value: TSerializeValue): OerConstant<TParseValue, TSerializeValue>;
    };
    // (undocumented)
    readonly length: SafeUnsignedInteger;
    // (undocumented)
    parseWithContext({ uint8Array }: ParseContext, offset: number): readonly [Uint8Array, SafeUnsignedInteger];
    // (undocumented)
    serializeWithContext(value: Uint8Array | Serializer): SerializeError | {
        (context: SerializeContext, offset: number): void;
        size: SafeUnsignedInteger;
    };
}

// @public (undocumented)
export class OerInt16Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 16;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export class OerInt16Number extends OerFixedIntegerNumber {
    // (undocumented)
    readonly size = 16;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export class OerInt32Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 32;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export class OerInt32Number extends OerFixedIntegerNumber {
    // (undocumented)
    readonly size = 32;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export class OerInt64Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 64;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export class OerInt8Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 8;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export class OerInt8Number extends OerFixedIntegerNumber {
    // (undocumented)
    readonly size = 8;
    // (undocumented)
    readonly type = "Int";
}

// @public (undocumented)
export abstract class OerIntegerBigint extends OerType<bigint> {
    // (undocumented)
    static readonly INT16_MAX = 32767n;
    // (undocumented)
    static readonly INT16_MIN = -32768n;
    // (undocumented)
    static readonly INT32_MAX = 2147483647n;
    // (undocumented)
    static readonly INT32_MIN = -2147483648n;
    // (undocumented)
    static readonly INT64_MAX = 9223372036854775807n;
    // (undocumented)
    static readonly INT64_MIN = -9223372036854775808n;
    // (undocumented)
    static readonly INT8_MAX = 127n;
    // (undocumented)
    static readonly INT8_MIN = -128n;
    // (undocumented)
    static readonly UINT16_MAX = 65535n;
    // (undocumented)
    static readonly UINT32_MAX = 4294967295n;
    // (undocumented)
    static readonly UINT64_MAX = 18446744073709551615n;
    // (undocumented)
    static readonly UINT8_MAX = 255n;
    // (undocumented)
    static readonly UINT_MIN = 0n;
}

// @public (undocumented)
export class OerObjectIdentifier extends OerType<string> {
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [string, number];
    // (undocumented)
    serializeWithContext(input: string): SerializeError | {
        ({ uint8Array }: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
}

// @public (undocumented)
export const OerOctetStringContaining: {
    new <TSubtype>(octetStringType: OerFixedOctetString | OerVariableOctetString, subType: OerType<TSubtype, TSubtype>): {
        readonly octetStringType: OerFixedOctetString | OerVariableOctetString;
        readonly subType: OerType<TSubtype, TSubtype>;
        parseWithContext(context: ParseContext, offset: number): ParseError | readonly [TSubtype, number];
        serializeWithContext(value: Uint8Array | TSubtype): SerializeError | {
            (context: SerializeContext, offset: number): void;
            size: SafeUnsignedInteger;
        } | {
            (context: SerializeContext, offset: number): SerializeError | undefined;
            size: number;
        };
        _tag: readonly [tagValue: number, tagClass: TagMarker] | undefined;
        parse(input: Uint8Array, offset?: number, options?: ParseOptions): {
            success: false;
            failure: ParseError;
        } | {
            success: true;
            value: TSubtype;
            length: number;
        };
        serialize(value: Uint8Array | TSubtype): {
            success: true;
            value: Uint8Array;
        } | {
            success: false;
            failure: SerializeError;
        };
        tag(tagValue: number, tagClass?: "application" | "context" | "private"): any;
        optional(): OerOptional<TSubtype, Uint8Array | TSubtype>;
        default(value: TSubtype): OerOptional<TSubtype, Uint8Array | TSubtype>;
        constant<TParseValue, TSerializeValue>(this: OerType<TParseValue, TSerializeValue>, value: TSerializeValue): OerConstant<TParseValue, TSerializeValue>;
    };
};

// @public (undocumented)
export class OerOptional<TParseValue, TSerializeValue> extends OerType<TParseValue, TSerializeValue> {
    constructor(subType: OerType<TParseValue, TSerializeValue>, defaultValue: TParseValue | undefined);
    // (undocumented)
    readonly defaultValue: TParseValue | undefined;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [TParseValue, number];
    // (undocumented)
    serializeWithContext(value: TSerializeValue): SerializeError | Serializer;
    // (undocumented)
    readonly subType: OerType<TParseValue, TSerializeValue>;
}

// @public (undocumented)
export class OerSequence<TShape extends OerSequenceShape> extends OerType<InferOerSequenceParseShape<TShape>, InferOerSequenceSerializeShape<TShape>> {
    constructor(sequenceShape: TShape);
    // (undocumented)
    extend<TExtensions extends Record<string, AnyOerType | Record<string, AnyOerType>>>(extensions: TExtensions): OerSequence<{
        root: ObjectShape;
        isExtensible: true;
        extensions: Simplify<TShape["extensions"] & TExtensions, {}>;
    }>;
    // (undocumented)
    extensible(): this;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [Simplify<InferObjectParseShape<TShape["root"]> & Partial<TShape["extensions"] extends infer T ? { [key in keyof T]: TShape["extensions"] extends OerType<infer K, never> ? K : InferObjectParseShape<TShape["extensions"][key]>; } : never>, {}>, number];
    // (undocumented)
    readonly sequenceShape: TShape;
    // (undocumented)
    serializeWithContext(input: InferOerSequenceSerializeShape<TShape>): SerializeError | {
        (context: SerializeContext, offset: number): void;
        size: number;
    };
}

// @public (undocumented)
export class OerSequenceOf<TShape extends AnyOerType> extends OerType<Infer<TShape>[], InferSerialize<TShape>[]> {
    constructor(sequenceOfShape: TShape);
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [Infer<TShape>[], number];
    // (undocumented)
    readonly sequenceOfShape: TShape;
    // (undocumented)
    serializeWithContext(input: InferSerialize<TShape>[]): SerializeError | {
        (context: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
}

// @public (undocumented)
export interface OerSequenceShape {
    // (undocumented)
    extensions: Record<string, ObjectShape>;
    // (undocumented)
    isExtensible: boolean;
    // (undocumented)
    root: ObjectShape;
}

// @public (undocumented)
export class OerString extends OerType<string> {
    constructor(length: NormalizedRange<number>, encoding: EncodingType, filterArray?: boolean[] | undefined);
    // (undocumented)
    readonly encoding: EncodingType;
    // (undocumented)
    readonly filterArray?: boolean[] | undefined;
    // (undocumented)
    from(characters: Alphabet): OerString;
    // (undocumented)
    readonly length: NormalizedRange<number>;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [string, number];
    // (undocumented)
    serializeWithContext(value: string): SerializeError | Serializer;
}

// @public (undocumented)
export abstract class OerType<TParseValue, TSerializeValue = TParseValue> {
    // (undocumented)
    constant<TParseValue, TSerializeValue>(this: OerType<TParseValue, TSerializeValue>, value: TSerializeValue): OerConstant<TParseValue, TSerializeValue>;
    // (undocumented)
    default(value: TParseValue): OerOptional<TParseValue, TSerializeValue>;
    // (undocumented)
    optional(): OerOptional<TParseValue, TSerializeValue>;
    // (undocumented)
    parse(input: Uint8Array, offset?: number, options?: ParseOptions): {
        success: true;
        value: TParseValue;
        length: number;
    } | {
        success: false;
        failure: ParseError;
    };
    // (undocumented)
    abstract parseWithContext(context: ParseContext, offset: number): readonly [value: TParseValue, length: number] | ParseError;
    // (undocumented)
    serialize(value: TSerializeValue): {
        success: true;
        value: Uint8Array;
    } | {
        success: false;
        failure: SerializeError;
    };
    // (undocumented)
    abstract serializeWithContext(value: TSerializeValue): Serializer | SerializeError;
    // (undocumented)
    tag(tagValue: number, tagClass?: Exclude<TagClass, "universal">): this;
    // (undocumented)
    _tag: readonly [tagValue: number, tagClass: TagMarker] | undefined;
}

// @public (undocumented)
export class OerUint16Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 16;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerUint16Number extends OerFixedIntegerNumber {
    // (undocumented)
    readonly size = 16;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerUint32Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 32;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerUint32Number extends OerFixedIntegerNumber {
    // (undocumented)
    readonly size = 32;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerUint64Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 64;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerUint8Bigint extends OerFixedIntegerBigint {
    // (undocumented)
    readonly size = 8;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerUint8Number extends OerFixedIntegerNumber {
    // (undocumented)
    readonly size = 8;
    // (undocumented)
    readonly type = "Uint";
}

// @public (undocumented)
export class OerVariableBitstring<TBitDefinition extends number> extends OerType<InferBitstringValue<TBitDefinition>> {
    constructor(bits: TBitDefinition);
    // (undocumented)
    readonly bits: TBitDefinition;
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [ReadonlyTuple<boolean, TBitDefinition>, number];
    // (undocumented)
    serializeWithContext(input: ReadonlyTuple<boolean, TBitDefinition>): SerializeError | {
        (context: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
}

// @public (undocumented)
export class OerVariableOctetString extends OerType<Uint8Array, Uint8Array | Serializer> {
    constructor(sizeRange: NormalizedRange<SafeUnsignedInteger>);
    // (undocumented)
    containing<T>(subType: OerType<T>): {
        readonly octetStringType: OerFixedOctetString | OerVariableOctetString;
        readonly subType: OerType<T, T>;
        parseWithContext(context: ParseContext, offset: number): ParseError | readonly [T, number];
        serializeWithContext(value: Uint8Array | T): SerializeError | {
            (context: BaseContext, offset: number): void;
            size: SafeUnsignedInteger;
        } | {
            (context: BaseContext, offset: number): SerializeError | undefined;
            size: number;
        };
        _tag: readonly [tagValue: number, tagClass: TagMarker] | undefined;
        parse(input: Uint8Array, offset?: number, options?: ParseOptions): {
            success: false;
            failure: ParseError;
        } | {
            success: true;
            value: T;
            length: number;
        };
        serialize(value: Uint8Array | T): {
            success: true;
            value: Uint8Array;
        } | {
            success: false;
            failure: SerializeError;
        };
        tag(tagValue: number, tagClass?: "application" | "context" | "private"): any;
        optional(): OerOptional<T, Uint8Array | T>;
        default(value: T): OerOptional<T, Uint8Array | T>;
        constant<TParseValue, TSerializeValue>(this: OerType<TParseValue, TSerializeValue>, value: TSerializeValue): OerConstant<TParseValue, TSerializeValue>;
    };
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [Uint8Array, number];
    // (undocumented)
    serializeWithContext(input: Uint8Array | Serializer): SerializeError | {
        (context: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
    // (undocumented)
    readonly sizeRange: NormalizedRange<SafeUnsignedInteger>;
}

// @public (undocumented)
export class OerVariableSignedInteger extends OerType<bigint> {
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [bigint, number];
    // (undocumented)
    serializeWithContext(input: bigint): SerializeError | {
        ({ uint8Array }: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
}

// @public (undocumented)
export class OerVariableUnsignedInteger extends OerIntegerBigint {
    // (undocumented)
    parseWithContext(context: ParseContext, offset: number): ParseError | readonly [bigint, number];
    // (undocumented)
    serializeWithContext(input: bigint): SerializeError | {
        ({ uint8Array }: SerializeContext, offset: number): SerializeError | undefined;
        size: number;
    };
}

// @public (undocumented)
export const parseBitstring: (context: ParseContext, offset: number, size: number) => unknown[];

// @public (undocumented)
export interface ParseOptions {
    // (undocumented)
    allowNoncanonical?: boolean;
}

// @public (undocumented)
export const printableString: (length?: Range_2<number>) => OerString;

// @public (undocumented)
export const sequence: <TRootShape extends ObjectShape>(sequenceShape: TRootShape) => OerSequence<{
    root: TRootShape;
    isExtensible: false;
    extensions: {};
}>;

// @public (undocumented)
export const sequenceOf: <TShape extends AnyOerType>(sequenceOfShape: TShape) => OerSequenceOf<TShape>;

// @public (undocumented)
export const serializeBitstring: (context: BaseContext, offset: number, input: InferBitstringValue<number>) => void;

// @public (undocumented)
export const uint16Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const uint16Number: () => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export const uint32Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const uint32Number: () => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export const uint64Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const uint8ArrayToHex: (uint8Array: Uint8Array, byteSeparator?: string) => string;

// @public (undocumented)
export const uint8Bigint: () => OerUint8Bigint | OerUint16Bigint | OerUint32Bigint | OerUint64Bigint | OerInt8Bigint | OerInt16Bigint | OerInt32Bigint | OerInt64Bigint | OerVariableUnsignedInteger | OerVariableSignedInteger;

// @public (undocumented)
export const uint8Number: () => OerUint8Number | OerUint16Number | OerUint32Number | OerInt8Number | OerInt16Number | OerInt32Number;

// @public (undocumented)
export const utf8String: (length?: Range_2<number>) => OerString;

// @public (undocumented)
export const visibleString: (length?: Range_2<number>) => OerString;

// (No @packageDocumentation comment for this package)

```
