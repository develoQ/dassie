import Database from "better-sqlite3"

import { createLogger } from "@dassie/lib-logger"
import { EffectContext, createService } from "@dassie/lib-reactive"

import { configSignal } from "../config"
import migrations from "./migrations"
import { migrate } from "./utils/migrate"

const logger = createLogger("das:node:database")

/**
 * Unique application ID for identifying the SQLite database as belonging to Dassie.
 *
 * Application ID was generated by first generating a random positive, signed, 32-bit integer and
 * replacing the second through fourth nibbles with the HEX digits "DA5" to represent Dassie.
 */
const DASSIE_SQLITE_APPLICATION_ID = 0x1d_a5_3b_81n

export const openDatabase = (sig: EffectContext) => {
  sig.run(sig.use(databaseService).effect)
}

export const databaseService = () =>
  createService((sig) => {
    const dataPath = sig.get(configSignal, (config) => config.dataPath)

    const database = new Database(`${dataPath}/dassie.sqlite3`)

    // SQLite INTEGERs are 64-bit signed integers, so we would like to get them as bigints from the database.
    database.defaultSafeIntegers(true)

    // If this is a brand-new, empty database, initialize it by setting the application ID
    if (
      database.pragma("application_id", { simple: true }) === 0n &&
      database.pragma("schema_version", { simple: true }) === 0n
    ) {
      logger.info("initializing a new sqlite database")
      database.pragma(`application_id = ${DASSIE_SQLITE_APPLICATION_ID}`)
    }

    // Database must have the correct application ID or we can't continue
    if (
      database.pragma("application_id", { simple: true }) !==
      DASSIE_SQLITE_APPLICATION_ID
    ) {
      throw new Error("Database file is not a valid Dassie node database")
    }

    migrate(database, migrations)

    return database
  })
